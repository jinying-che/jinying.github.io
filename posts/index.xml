<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Che Jinying</title>
    <link>https://jinying-che.github.io/posts/</link>
    <description>Recent content in Posts on Che Jinying</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Sep 2020 19:47:01 +0800</lastBuildDate>
    
	<atom:link href="https://jinying-che.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go Basic</title>
      <link>https://jinying-che.github.io/posts/go/go_basic/</link>
      <pubDate>Sun, 27 Sep 2020 19:47:01 +0800</pubDate>
      
      <guid>https://jinying-che.github.io/posts/go/go_basic/</guid>
      <description>Go Basic  the basic of go
 Channel 基本性质  在go的运行时环境，对同一个通道，发送操作是互斥的（即同一时刻，只有一个发送操作会执行），同理，接受操作也是互斥的 元素进入通道，分为两步，为一个原子操作：  对元素进行复制 将副本放入通道内部   元素从通道取出取出，分为三步，为一个原子操作：  对元素进行复制 赋值给接收方 在通道中删除    缓冲与非缓冲   非缓冲通道，send和receive操作会彼此阻塞，直到彼此准备好数据，比如：
func main(){ c := make(chan int) //当前线程send数据后，会挂起，直至channel中的数据被receive后，才继续执行 c &amp;lt;- 1 //下面这句永远不会执行，导致deadlock fmt.Println(&amp;lt;- c) }   Channel Close   Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic. (don&amp;rsquo;t close a channel from the receiver side and don&amp;rsquo;t close a channel if the channel has multiple concurrent senders.</description>
    </item>
    
    <item>
      <title>First</title>
      <link>https://jinying-che.github.io/posts/first/</link>
      <pubDate>Sun, 27 Sep 2020 19:32:13 +0800</pubDate>
      
      <guid>https://jinying-che.github.io/posts/first/</guid>
      <description>Hello Hugo! This is my first blog in my personal website.</description>
    </item>
    
  </channel>
</rss>